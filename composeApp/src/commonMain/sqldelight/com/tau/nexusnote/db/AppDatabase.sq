import kotlin.collections.List;
import kotlin.collections.Map;

-- METADATA: Type System Definitions --

CREATE TABLE SchemaDef (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL UNIQUE,
    kind TEXT NOT NULL CHECK (kind IN ('ENTITY', 'RELATION'))
);

CREATE TABLE AttributeDef (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    schema_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    data_type TEXT NOT NULL CHECK (data_type IN ('TEXT', 'INTEGER', 'REAL', 'BOOLEAN')),
    FOREIGN KEY(schema_id) REFERENCES SchemaDef(id) ON DELETE CASCADE,
    UNIQUE(schema_id, name)
);

CREATE TABLE RoleDef (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    schema_id INTEGER NOT NULL,
    name TEXT NOT NULL,
    direction TEXT NOT NULL CHECK (direction IN ('SOURCE', 'TARGET')),
    cardinality TEXT NOT NULL CHECK (cardinality IN ('ONE', 'MANY')),
    FOREIGN KEY(schema_id) REFERENCES SchemaDef(id) ON DELETE CASCADE,
    UNIQUE(schema_id, name)
);

-- Defines allowed Node Schemas for a specific Role.
-- If no rows exist for a role_id, any Node Schema is allowed (logic handled in app).
CREATE TABLE RoleAllowedSchema (
    role_id INTEGER NOT NULL,
    allowed_schema_id INTEGER NOT NULL,
    PRIMARY KEY(role_id, allowed_schema_id),
    FOREIGN KEY(role_id) REFERENCES RoleDef(id) ON DELETE CASCADE,
    FOREIGN KEY(allowed_schema_id) REFERENCES SchemaDef(id) ON DELETE CASCADE
);

-- DATA: Graph Instances --

-- Base table for both Nodes and Edges (Relations)
CREATE TABLE Entity (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    created_at INTEGER NOT NULL
);

-- Defines which schemas an entity belongs to.
-- Supports Composite Nodes (One entity can have multiple rows here).
CREATE TABLE EntityType (
    entity_id INTEGER NOT NULL,
    schema_id INTEGER NOT NULL,
    PRIMARY KEY(entity_id, schema_id),
    FOREIGN KEY(entity_id) REFERENCES Entity(id) ON DELETE CASCADE,
    FOREIGN KEY(schema_id) REFERENCES SchemaDef(id) ON DELETE CASCADE
);

-- Stores values for attributes.
-- Strict typing: Only ONE of the val_ columns should be populated based on AttributeDef.data_type.
CREATE TABLE AttributeValue (
    entity_id INTEGER NOT NULL,
    attribute_def_id INTEGER NOT NULL,
    val_text TEXT,
    val_int INTEGER,
    val_real REAL,
    val_bool INTEGER, -- 0 for False, 1 for True
    PRIMARY KEY(entity_id, attribute_def_id),
    FOREIGN KEY(entity_id) REFERENCES Entity(id) ON DELETE CASCADE,
    FOREIGN KEY(attribute_def_id) REFERENCES AttributeDef(id) ON DELETE CASCADE
);

-- Defines the connections in the graph.
-- Links a 'Relation' Entity to a 'Player' Entity (Node or another Relation) via a specific Role.
CREATE TABLE RelationLink (
    relation_entity_id INTEGER NOT NULL,
    player_entity_id INTEGER NOT NULL,
    role_def_id INTEGER NOT NULL,
    PRIMARY KEY(relation_entity_id, player_entity_id, role_def_id),
    FOREIGN KEY(relation_entity_id) REFERENCES Entity(id) ON DELETE CASCADE,
    FOREIGN KEY(player_entity_id) REFERENCES Entity(id) ON DELETE CASCADE,
    FOREIGN KEY(role_def_id) REFERENCES RoleDef(id) ON DELETE CASCADE
);

-- VISUALS: Layout Constraints --
CREATE TABLE LayoutConstraint (
    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    type TEXT NOT NULL,
    entity_ids_json TEXT AS List<kotlin.Long> NOT NULL,
    params_json TEXT AS Map<kotlin.String, kotlin.String> NOT NULL
);

--- QUERIES ---

-- SchemaDef Queries --
selectAllSchemas:
SELECT * FROM SchemaDef;

selectSchemaById:
SELECT * FROM SchemaDef WHERE id = ?;

insertSchema:
INSERT INTO SchemaDef(name, kind) VALUES (?, ?);

updateSchemaName:
UPDATE SchemaDef SET name = ? WHERE id = ?;

deleteSchemaById:
DELETE FROM SchemaDef WHERE id = ?;

lastInsertRowId:
SELECT last_insert_rowid();

-- AttributeDef Queries --
selectAllAttributeDefs:
SELECT * FROM AttributeDef;

selectAttributesBySchemaId:
SELECT * FROM AttributeDef WHERE schema_id = ?;

insertAttributeDef:
INSERT INTO AttributeDef(schema_id, name, data_type) VALUES (?, ?, ?);

updateAttributeDef:
UPDATE AttributeDef SET name = ?, data_type = ? WHERE id = ?;

updateAttributeDefName:
UPDATE AttributeDef SET name = ? WHERE id = ?;

deleteAttributeDef:
DELETE FROM AttributeDef WHERE id = ?;

-- RoleDef Queries --
selectAllRoleDefs:
SELECT * FROM RoleDef;

selectRolesBySchemaId:
SELECT * FROM RoleDef WHERE schema_id = ?;

insertRoleDef:
INSERT INTO RoleDef(schema_id, name, direction, cardinality) VALUES (?, ?, ?, ?);

updateRoleDef:
UPDATE RoleDef SET name = ?, direction = ?, cardinality = ? WHERE id = ?;

updateRoleDefName:
UPDATE RoleDef SET name = ? WHERE id = ?;

deleteRoleDef:
DELETE FROM RoleDef WHERE id = ?;

-- RoleAllowedSchema Queries --
selectAllRoleAllowedSchemas:
SELECT * FROM RoleAllowedSchema;

selectAllowedSchemasForRole:
SELECT allowed_schema_id FROM RoleAllowedSchema WHERE role_id = ?;

insertRoleAllowedSchema:
INSERT INTO RoleAllowedSchema(role_id, allowed_schema_id) VALUES (?, ?);

deleteAllowedSchemasForRole:
DELETE FROM RoleAllowedSchema WHERE role_id = ?;

-- Entity Queries --
selectAllEntities:
SELECT * FROM Entity;

insertEntity:
INSERT INTO Entity(created_at) VALUES (?);

selectEntityById:
SELECT * FROM Entity WHERE id = ?;

deleteEntityById:
DELETE FROM Entity WHERE id = ?;

countEntities:
SELECT COUNT(*) FROM Entity;

-- EntityType Queries --
selectAllEntityTypes:
SELECT * FROM EntityType;

insertEntityType:
INSERT INTO EntityType(entity_id, schema_id) VALUES (?, ?);

-- Get all types (schemas) for a specific entity
selectSchemasForEntity:
SELECT SchemaDef.*
FROM SchemaDef
JOIN EntityType ON SchemaDef.id = EntityType.schema_id
WHERE EntityType.entity_id = ?;

-- Get all entities that implement a specific schema
selectEntitiesBySchema:
SELECT Entity.*
FROM Entity
JOIN EntityType ON Entity.id = EntityType.entity_id
WHERE EntityType.schema_id = ?;

-- AttributeValue Queries --
selectAllAttributeValues:
SELECT * FROM AttributeValue;

insertAttributeValue:
INSERT INTO AttributeValue(entity_id, attribute_def_id, val_text, val_int, val_real, val_bool)
VALUES (?, ?, ?, ?, ?, ?);

updateAttributeValue:
UPDATE AttributeValue
SET val_text = ?, val_int = ?, val_real = ?, val_bool = ?
WHERE entity_id = ? AND attribute_def_id = ?;

-- Fetch all attributes for an entity, joining with definition to get names/types
selectAttributeValuesForEntity:
SELECT AttributeValue.*, AttributeDef.name AS def_name, AttributeDef.data_type AS def_type
FROM AttributeValue
JOIN AttributeDef ON AttributeValue.attribute_def_id = AttributeDef.id
WHERE AttributeValue.entity_id = ?;

-- RelationLink Queries --
selectAllRelationLinks:
SELECT * FROM RelationLink;

insertRelationLink:
INSERT INTO RelationLink(relation_entity_id, player_entity_id, role_def_id)
VALUES (?, ?, ?);

-- Get all connections for a specific Relation (Edge)
-- e.g., For "Marriage" (ID 5), get "Bob" (Husband) and "Alice" (Wife)
selectLinksForRelation:
SELECT RelationLink.*, RoleDef.name AS role_name, RoleDef.direction, RoleDef.cardinality
FROM RelationLink
JOIN RoleDef ON RelationLink.role_def_id = RoleDef.id
WHERE RelationLink.relation_entity_id = ?;

-- Get all Relations where a specific Entity is a player
-- e.g., Find all "Marriages" or "Employments" that "Bob" is involved in
selectRelationsForPlayer:
SELECT RelationLink.*
FROM RelationLink
WHERE RelationLink.player_entity_id = ?;

-- LayoutConstraint Queries --
selectAllConstraints:
SELECT * FROM LayoutConstraint;

insertConstraint:
INSERT INTO LayoutConstraint(type, entity_ids_json, params_json)
VALUES (?, ?, ?);

deleteConstraintById:
DELETE FROM LayoutConstraint WHERE id = ?;